#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Nov 11 17:47:37 2025
@author: helenemerson
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from scipy.signal import butter, filtfilt

# Load in inverse kinematics data from OpenSim
# =============================================================================
IK_file = "InverseKinematics_GaitData.mot"

# OpenSim uese .mot file format. We can use pandas to read the file.
with open(IK_file, 'r') as f:
    lines = f.readlines()

start_idx = None
for i, line in enumerate(lines):
    if "endheader" in line.lower():
        start_idx = i + 1
        break

data = pd.read_csv(IK_file, sep=r'\s+', skiprows=start_idx)

# Includes all of the 23 coordinates tracked with OpenSim simulation. 
all_coords = {col: data[col].values for col in data.columns}

# Pull time
time = all_coords['time']

# Pull relevant angles and convert to radians
r_knee_angle = np.deg2rad(all_coords['knee_angle_r'])
l_knee_angle = np.deg2rad(all_coords['knee_angle_l'])
r_hip_angle = np.deg2rad(all_coords['hip_flexion_r'])
l_hip_angle = np.deg2rad(all_coords['hip_flexion_l'])

# Filter data for better visualization, more realistic figure movement 
# (6Hz is customary for kinematic filtering)
def butter_lowpass_filter(data, cutoff=6, fs=150, order=2):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low')
    return filtfilt(b, a, data)

# Filter is not necessary, so handle exception here
try:
    r_knee_angle = butter_lowpass_filter(r_knee_angle)
    l_knee_angle = butter_lowpass_filter(l_knee_angle)
    r_hip_angle = butter_lowpass_filter(r_hip_angle)
    l_hip_angle = butter_lowpass_filter(l_hip_angle)
except:
    pass

# Define constant body parameters
# =============================================================================

# Somewhat arbitrary
thigh_length = 0.3
shank_length = 0.2
foot_length = 0.05
head_radius = 0.1
hip_joint = np.array((0.0, 0.5))

# Set up stance/swing check
foot_contact_height = 0.03
ankle_vel_threshold = 0.02
r_in_stance = l_in_stance = False
r_foot_anchor = l_foot_anchor = None
prev_r_ankle = prev_l_ankle = np.array([0.0, 0.0])

# Functions for forcing more natural motion 
# Forward kinematics
def fk_from_hip(hip_pos, hip_angle, knee_angle):
    knee = hip_pos + thigh_length * np.array([np.sin(hip_angle), np.cos(hip_angle)])
    ankle = knee + shank_length * np.array([np.sin(hip_angle + knee_angle), np.cos(hip_angle + knee_angle)])
    foot_pt = ankle + foot_length * np.array([1, 0])  # foot points forward along +X
    return knee, ankle, foot_pt

# Inverse kinematics
def hip_from_ankle(ankle_pos, hip_angle, knee_angle):
    shank_vec = shank_length * np.array([np.sin(hip_angle + knee_angle), np.cos(hip_angle + knee_angle)])
    knee_pos = ankle_pos - shank_vec
    thigh_vec = thigh_length * np.array([np.sin(hip_angle), np.cos(hip_angle)])
    hip_pos = knee_pos - thigh_vec
    return hip_pos


# Set up plots here
# =============================================================================
fig, ax = plt.subplots()
ax.set_xlim(-0.5, 1.5)
ax.set_ylim(-0.2, 1.5)
ax.set_aspect('equal')

head = plt.Circle((0, 1), head_radius, fill=False, color='black')
ax.add_patch(head)

torso_line, = ax.plot([0, 0], [1, 0.5], color='black')
r_arm_line, = ax.plot([0, 0.15], [0.75, 0.55], color='black')
l_arm_line, = ax.plot([0, -0.15], [0.75, 0.55], color='black')

r_thigh_line, = ax.plot([], [], color='black')
r_shank_line, = ax.plot([], [], color='black')
r_foot_line, = ax.plot([], [], color='black')
l_thigh_line, = ax.plot([], [], color='black')
l_shank_line, = ax.plot([], [], color='black')
l_foot_line, = ax.plot([], [], color='black')

treadmill_line, = ax.plot([-0.25, 0.35], [0.02, 0.02], color='black', linestyle='-', linewidth=5)
treadmill_vertical, = ax.plot([0.35, 0.35], [0, 0.6], color='black', linestyle='-', linewidth=3)

plt.axhline(y=0, color='black', linestyle='--', linewidth=2)

ax.set_axis_off()

# initialize text box, 'text' must be returned as an artist from the update() 
# function to show up on each frame
text = ax.text(0.70, 0.8, '', bbox=dict(facecolor='yellow', alpha=0.5, boxstyle='round,pad=1'),
            fontsize=12,horizontalalignment='right',
     verticalalignment='center', transform=ax.transAxes)

# Update function for animation
# =============================================================================
def update(frame):
    # Define global variables that will be updated but not returned 
    global hip_joint, r_in_stance, l_in_stance, r_foot_anchor, l_foot_anchor, prev_r_ankle, prev_l_ankle
        
    # Current state of hip and knee
    r_hip_angle_now = r_hip_angle[frame]
    l_hip_angle_now = l_hip_angle[frame]
    r_knee_angle_now = r_knee_angle[frame]
    l_knee_angle_now = l_knee_angle[frame]

    # Forward kinematics - knee, ankle, and foot position from hip
    knee_r, ankle_r, foot_r = fk_from_hip(hip_joint, r_hip_angle_now, r_knee_angle_now)
    knee_l, ankle_l, foot_l = fk_from_hip(hip_joint, l_hip_angle_now, l_knee_angle_now)

    # Velocities
    r_dx = ankle_r[0] - prev_r_ankle[0]
    l_dx = ankle_l[0] - prev_l_ankle[0]
    
    
    # Checks if the ankle is geting close to the ground and slowing down (heel strike)
    r_contact = (ankle_r[1] < foot_contact_height) and (abs(r_dx) < ankle_vel_threshold)
    l_contact = (ankle_l[1] < foot_contact_height) and (abs(l_dx) < ankle_vel_threshold)

    # Choose stance foot
    # Anchor "locks" the ankle joint in position during stance by maintaining position from previous frame
    if r_contact and not r_in_stance:
        r_in_stance, l_in_stance = True, False
        r_foot_anchor = ankle_r.copy()
    if l_contact and not l_in_stance:
        l_in_stance, r_in_stance = True, False
        l_foot_anchor = ankle_l.copy()
            

    if r_in_stance and r_foot_anchor:
        hip_joint = hip_from_ankle(r_foot_anchor, r_hip_angle_now, r_knee_angle_now)
    elif l_in_stance and l_foot_anchor:
        hip_joint = hip_from_ankle(l_foot_anchor, l_hip_angle_now, l_knee_angle_now)


    # Define hip to knee
    r_knee = hip_joint + thigh_length * np.array([np.sin(r_hip_angle_now), -np.cos(r_hip_angle_now)])
    l_knee = hip_joint + thigh_length * np.array([np.sin(l_hip_angle_now), -np.cos(l_hip_angle_now)])
    
    # Define knee to ankle
    r_ankle = r_knee + shank_length * np.array([np.sin(r_hip_angle_now + r_knee_angle_now), -np.cos(r_hip_angle_now + r_knee_angle_now)])
    l_ankle = l_knee + shank_length * np.array([np.sin(l_hip_angle_now + l_knee_angle_now), -np.cos(l_hip_angle_now + l_knee_angle_now)])
    
    
    # Set stance/swing label text display based on ankle position
    if r_ankle[1] < foot_contact_height and l_ankle[1] > foot_contact_height:
        text.set_text('Right Stance')
        text.set_color('red')
        r_thigh_line.set_color('red')
        r_shank_line.set_color('red')
        r_foot_line.set_color('red')
    elif l_ankle[1] < foot_contact_height and r_ankle[1] > foot_contact_height:
        text.set_text('Left Stance')
        text.set_color('blue')
        l_thigh_line.set_color('blue')
        l_shank_line.set_color('blue')
        l_foot_line.set_color('blue')
    else:
        text.set_text('')
        text.set_color('black')
        r_thigh_line.set_color('black')
        r_shank_line.set_color('black')
        r_foot_line.set_color('black')
        l_thigh_line.set_color('black')
        l_shank_line.set_color('black')
        l_foot_line.set_color('black')      
    
    # Foot endpoint
    r_foot_end = r_ankle + foot_length * np.array([1, 0])
    l_foot_end = l_ankle + foot_length * np.array([1, 0])

    # Update leg lines
    r_thigh_line.set_data([hip_joint[0], r_knee[0]], [hip_joint[1], r_knee[1]])
    r_shank_line.set_data([r_knee[0], r_ankle[0]], [r_knee[1], r_ankle[1]])
    r_foot_line.set_data([r_ankle[0], r_foot_end[0]], [r_ankle[1], r_foot_end[1]])

    l_thigh_line.set_data([hip_joint[0], l_knee[0]], [hip_joint[1], l_knee[1]])
    l_shank_line.set_data([l_knee[0], l_ankle[0]], [l_knee[1], l_ankle[1]])
    l_foot_line.set_data([l_ankle[0], l_foot_end[0]], [l_ankle[1], l_foot_end[1]])

    # Move torso and head along with hip for more natural motion
    torso_top = hip_joint + np.array([0, 0.4])
    torso_line.set_data([hip_joint[0], torso_top[0]], [hip_joint[1], torso_top[1]])
    head.center = torso_top + np.array([0, head_radius])

    # Make arms swing in phase with legs
    r_arm_line.set_data([torso_top[0], torso_top[0] + 0.15*np.cos(l_hip_angle_now)],
                        [torso_top[1]-0.15, torso_top[1]-0.35])
    l_arm_line.set_data([torso_top[0], torso_top[0] - 0.15*np.cos(r_hip_angle_now)],
                        [torso_top[1]-0.15, torso_top[1]-0.35])
    # Store for next frame
    prev_r_ankle, prev_l_ankle = ankle_r.copy(), ankle_l.copy()
    return (r_thigh_line, r_shank_line, r_foot_line,
            l_thigh_line, l_shank_line, l_foot_line,
            torso_line, r_arm_line, l_arm_line, head, 
            treadmill_line, treadmill_vertical, text)

# Animate with update(), save to gif
# =============================================================================
ani = FuncAnimation(fig, update, frames=len(time[0:999]), interval=50, blit=True)
plt.show()

writer = PillowWriter(fps=30)
ani.save('DEMO_Walking_StickFig.gif', writer=writer, dpi=80)
